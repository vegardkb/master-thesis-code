import numpy as np
from matplotlib import pyplot as plt
import matplotlib.cm as cm
import pickle
import copy
import os

from fio import (
    generate_global_results_dir,
    gen_pickle_fname,
    generate_figures_dir,
    gen_image_fname,
)
from plotters import plot_slope_box, plot_slope_scatter
from data_analysis_events import EventType
from sklearn.decomposition import PCA
from sklearn.manifold import LocallyLinearEmbedding, TSNE
from sklearn.cluster import KMeans
from light_response_feature_extract import create_empty_results_dict
from scipy.stats import alexandergovern, tukey_hsd, linregress


NEGATIVE_RGB = (165, 165, 165)  # gray
SUBTHRESHOLD_RGB = (146, 243, 240)  # light blue
AMPLIFYING_RGB = (209, 128, 7)  # orange-ish
ATTENUATING_RGB = (149, 243, 146)  # light green
UNDEFINED_RGB = (255, 255, 255)  # white
EARLY_RGB = (52, 179, 86)  # green
MIDDLE_RGB = (191, 107, 29)  # orange-brown ish
LATE_RGB = (140, 24, 24)  # red


EXP_NAMES = [
    "20211112_13_23_43_GFAP_GCamp6s_F2_PTZ",
    "20211112_18_30_27_GFAP_GCamp6s_F5_c2",
    "20211112_19_48_54_GFAP_GCamp6s_F6_c3",
    "20211117_21_31_08_GFAP_GCamp6s_F6_PTZ",
    "20211119_16_36_20_GFAP_GCamp6s_F4_PTZ",
    "20220211_13_18_56_GFAP_GCamp6s_F2_C",
    "20220412_12_32_27_GFAP_GCamp6s_F2_PTZ",
    "20220412_13_59_55_GFAP_GCamp6s_F3_C",
]
STATS_FNAME = "stats_light_response"

N_REGIONS = 8
DISTAL_REG = 0
PROXIMAL_REG = N_REGIONS - 1

CELL_LENGTH_THRESHOLDS = [40, 60]

# ISIS = [300, 120, 60, 30, 15]
ISIS = [300, 120, 60]

REG_CM = cm.viridis_r

SIG_SINGLE = 0.05
SIG_DOUBLE = 0.01
SIG_TRIPLE = 0.001


def get_indices(results_dict, spec_dict):
    """
    results_dict: dictionary generated by light_response_feature_extract
    spec_dict: dictionary specifying what events to get indices for, values are lists

    return: list of indices corresponding to events that adhere to spec_dict

    example spec_dict:
        {
            "regions": ["r1"],
            "ptz": [True],
            "isi": [300],
        }
        This will give indices for all responses
        where the fish was treated with ptz and 300 seconds passed since last light stim.
        "regions" key is ignored and used elsewhere since one index includes all regions
    """

    event_ind_list = []
    num_events = len(results_dict["exp_name"])
    for event_ind in range(num_events):
        include_evt = True
        for key, val_list in spec_dict.items():
            if key == "regions":
                continue

            if results_dict[key][event_ind] not in val_list:
                include_evt = False
                break

        if include_evt:
            event_ind_list.append(event_ind)

    return event_ind_list


def filter_event_indices(path, threshold, results_dict, threshold_upper=None):
    tmp = copy.deepcopy(results_dict)
    for key in path:
        tmp = tmp[key]
    x = tmp

    ind_pos = []
    ind_neg = []
    nan_arr_bool = np.isnan(x)
    for i, val in enumerate(x):
        if nan_arr_bool[i]:
            continue

        if threshold_upper is not None:
            if val >= threshold and val < threshold_upper:
                ind_pos.append(i)

            else:
                ind_neg.append(i)

        else:
            if val >= threshold:
                ind_pos.append(i)

            else:
                ind_neg.append(i)

    return ind_pos, ind_neg


def get_results_dict(results_dict, event_ind_list, spec_dict):
    region_keys = spec_dict["regions"]
    sub_results_dict = create_empty_results_dict(region_keys)

    for evt_ind in event_ind_list:
        sub_results_dict["exp_name"].append(results_dict["exp_name"][evt_ind])
        sub_results_dict["roi_number"].append(results_dict["roi_number"][evt_ind])
        sub_results_dict["isi"].append(results_dict["isi"][evt_ind])
        sub_results_dict["ptz"].append(results_dict["ptz"][evt_ind])
        sub_results_dict["evt_num"].append(results_dict["evt_num"][evt_ind])
        sub_results_dict["amp_slope"].append(results_dict["amp_slope"][evt_ind])
        sub_results_dict["t_onset_slope"].append(results_dict["t_onset_slope"][evt_ind])
        sub_results_dict["t_onset_pearsonr"].append(
            results_dict["t_onset_pearsonr"][evt_ind]
        )
        sub_results_dict["t_onset_density_slope"].append(
            results_dict["t_onset_density_slope"][evt_ind]
        )
        sub_results_dict["t_peak_slope"].append(results_dict["t_peak_slope"][evt_ind])
        sub_results_dict["t_lag_av_slope"].append(
            results_dict["t_lag_av_slope"][evt_ind]
        )
        sub_results_dict["t_lag_distal_slope"].append(
            results_dict["t_lag_distal_slope"][evt_ind]
        )
        sub_results_dict["prop_dist"].append(results_dict["prop_dist"][evt_ind])

        for reg_key in region_keys:
            sub_results_dict["regions"][reg_key]["peak"].append(
                results_dict["regions"][reg_key]["peak"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["bl"].append(
                results_dict["regions"][reg_key]["bl"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["amp"].append(
                results_dict["regions"][reg_key]["amp"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["rel_diff_amp"].append(
                results_dict["regions"][reg_key]["rel_diff_amp"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_onset"].append(
                results_dict["regions"][reg_key]["t_onset"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["rel_t_onset"].append(
                results_dict["regions"][reg_key]["rel_t_onset"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["diff_dxdt"].append(
                results_dict["regions"][reg_key]["diff_dxdt"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_onsets"].append(
                results_dict["regions"][reg_key]["t_onsets"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["diff_dxdts"].append(
                results_dict["regions"][reg_key]["diff_dxdts"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_onset_density"].append(
                results_dict["regions"][reg_key]["t_onset_density"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["k_onset"].append(
                results_dict["regions"][reg_key]["k_onset"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_rise"].append(
                results_dict["regions"][reg_key]["t_rise"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_peak"].append(
                results_dict["regions"][reg_key]["t_peak"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_decay"].append(
                results_dict["regions"][reg_key]["t_decay"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_constant_decay"].append(
                results_dict["regions"][reg_key]["t_constant_decay"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_lag_av"].append(
                results_dict["regions"][reg_key]["t_lag_av"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["corr_av"].append(
                results_dict["regions"][reg_key]["corr_av"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_lag_distal"].append(
                results_dict["regions"][reg_key]["t_lag_distal"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["corr_distal"].append(
                results_dict["regions"][reg_key]["corr_distal"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["reg_position"].append(
                results_dict["regions"][reg_key]["reg_position"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["acc_onset"].append(
                results_dict["regions"][reg_key]["acc_onset"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["acc_middle"].append(
                results_dict["regions"][reg_key]["acc_middle"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["acc_offset"].append(
                results_dict["regions"][reg_key]["acc_offset"][evt_ind]
            )

    return sub_results_dict


def grab_columns(results_dict, paths):
    """
    paths: list of lists specifying path to list to extract

    Example paths:
        [["isi"], ["regions", "r1", "amp"]]
    """
    columns = []
    for path in paths:
        tmp = results_dict
        for key in path:
            tmp = tmp[key]

        columns.append(tmp)

    return columns


def get_t_onset_groups(t_onsets):
    t_onset_meds = np.median(t_onsets, axis=0)
    t_onset_ps = t_onsets[PROXIMAL_REG]
    t_val_1 = 4
    t_val_2 = 10
    ind_early = []
    ind_middle = []
    ind_late = []
    for i, t_onset_med, t_onset_p in zip(
        range(len(t_onset_meds)), t_onset_meds, t_onset_ps
    ):
        if (t_onset_med > t_val_1 and t_onset_med < t_val_2) or (
            t_onset_p > t_val_1 and t_onset_p < t_val_2
        ):
            ind_middle.append(i)
        elif t_onset_med < t_val_1:
            ind_early.append(i)
        else:
            ind_late.append(i)

    ind_cats = [ind_early, ind_middle, ind_late]
    cat_labels = ["Early", "Middle", "Late"]

    return ind_cats, cat_labels


def plot_stat_per_region_scatter(
    results_dict,
    reg_colors,
    stat_key,
    scale_path,
    evt_num,
    cell_length,
    save_dir=None,
    fnames=None,
    opt_spec_dict=None,
):
    do_scaling = scale_path[0].lower() != "none"
    if do_scaling:
        scale_min, scale_max = scale_min_max(
            results_dict, [scale_path], [False, True], evt_num, cell_length
        )

    for i, ptz in enumerate([False, True]):
        spec_dict = {
            "isi": [
                300,
            ],
            "exp_name": EXP_NAMES,
            "ptz": [ptz],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "evt_num": evt_num,
            "cell_length": cell_length,
        }
        if opt_spec_dict is not None:
            for key, val in opt_spec_dict.items():
                spec_dict[key] = val
        evt_indices = get_indices(results_dict, spec_dict)
        sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
        stat_paths = [
            ["regions", f"r{reg_num+1}", stat_key] for reg_num in range(N_REGIONS)
        ]
        stat_columns = grab_columns(sub_results_dict, stat_paths)

        if do_scaling:
            scale_columns = grab_columns(sub_results_dict, [scale_path])
            s_max = 20
            s_min = 1
            scale = np.array(scale_columns[0])
            dot_size = ((scale - scale_min) / (scale_max - scale_min)) * (
                s_max - s_min
            ) + s_min

        else:
            dot_size = 10

        plt.figure()
        dist = 1
        width = 0.5

        for reg_num in range(N_REGIONS):
            y = stat_columns[reg_num]

            num_points = len(y)
            x = np.linspace(reg_num * dist, reg_num * dist + width, num_points)
            plt.scatter(x, y, color=reg_colors[reg_num], s=dot_size)

        plt.xlabel("Region")
        plt.ylabel(stat_key)
        group = "ptz" if ptz else "ctrl"
        if opt_spec_dict is not None:
            for key, val in opt_spec_dict.items():
                group += f" {key}: {val}"

        plt.title(f"{stat_key} by region " + group)
        if not (save_dir is None or fnames is None):
            plt.tight_layout()
            plt.savefig(gen_image_fname(save_dir, fnames[i]))


def plot_stat_per_region_violin(
    results_dict,
    regions,
    stat_key,
    evt_num,
    cell_length,
    ylabel,
    opt_spec_dict=None,
    normalize=False,
    subtract_distal=False,
    percent=False,
    test_median=False,
):

    data = []

    for ptz in [False, True]:
        spec_dict = {
            "isi": [
                300,
            ],
            "exp_name": EXP_NAMES,
            "ptz": [ptz],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "evt_num": evt_num,
            "cell_length": cell_length,
        }
        if opt_spec_dict is not None:
            for key, val in opt_spec_dict.items():
                spec_dict[key] = val
        evt_indices = get_indices(results_dict, spec_dict)
        sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
        stat_paths = [
            ["regions", f"r{reg_num+1}", stat_key] for reg_num in range(N_REGIONS)
        ]
        stat_columns = np.array(grab_columns(sub_results_dict, stat_paths))
        not_nan = np.logical_not(np.any(np.isnan(stat_columns), axis=0))
        stat_columns = stat_columns[:, not_nan]

        if normalize:
            ref = stat_columns[0]
            stat_columns = (stat_columns - ref) / ref

        if subtract_distal:
            ref = stat_columns[0]
            stat_columns = stat_columns - ref

        if percent:
            stat_columns = stat_columns * 100

        reg_filt_stat = [stat_columns[reg_num] for reg_num in regions]
        data.append(reg_filt_stat)

    data1 = tuple(data[0])
    data2 = tuple(data[1])

    title = ""
    ns = None
    ss = None
    ds = None
    ts = None

    if test_median:
        groups = []
        for i in range(len(data1)):
            groups.append(data1[i])
            groups.append(data2[i])

        ap = alexandergovern(*groups)
        title += f"A-stat = {ap.statistic}, p-val = {ap.pvalue}"

        tuk = tukey_hsd(*groups)
        tuk_p = tuk.pvalue
        ns = tuk_p > SIG_SINGLE
        ss = np.logical_and(tuk_p <= SIG_SINGLE, tuk_p > SIG_DOUBLE)
        ds = np.logical_and(tuk_p <= SIG_DOUBLE, tuk_p > SIG_TRIPLE)
        ts = tuk_p <= SIG_TRIPLE

    fig, ax = plt.subplots()

    points_gauss = 100

    v1 = ax.violinplot(
        data1,
        points=points_gauss,
        showmeans=False,
        showextrema=False,
        showmedians=False,
    )

    q1, q2, q3 = np.percentile(data1, [25, 50, 75], axis=1)
    med_line_length = 0.1
    q_line_length = 0.06
    med_width = 1
    q_width = 0.6

    for i, b in enumerate(v1["bodies"]):
        # get the center
        m = np.mean(b.get_paths()[0].vertices[:, 0])
        # modify the paths to not go further right than the center
        b.get_paths()[0].vertices[:, 0] = np.clip(
            b.get_paths()[0].vertices[:, 0], -np.inf, m
        )
        b.set_facecolor("darkgray")
        b.set_edgecolor("black")
        b.set_alpha(0.7)
        ax.hlines([q2[i]], m - med_line_length, m, color="black", lw=med_width)
        ax.hlines([q1[i], q3[i]], m - q_line_length, m, color="black", lw=q_width)

    v2 = ax.violinplot(
        data2,
        points=points_gauss,
        showmeans=False,
        showextrema=False,
        showmedians=False,
    )

    q1, q2, q3 = np.percentile(data2, [25, 50, 75], axis=1)

    for i, b in enumerate(v2["bodies"]):
        # get the center
        m = np.mean(b.get_paths()[0].vertices[:, 0])
        # modify the paths to not go further left than the center
        b.get_paths()[0].vertices[:, 0] = np.clip(
            b.get_paths()[0].vertices[:, 0], m, np.inf
        )
        b.set_facecolor("brown")
        b.set_edgecolor("black")
        b.set_alpha(0.7)
        ax.hlines([q2[i]], m, m + med_line_length, color="black", lw=med_width)
        ax.hlines([q1[i], q3[i]], m, m + q_line_length, color="black", lw=q_width)

    ax.legend([v1["bodies"][0], v2["bodies"][0]], ["ctrl", "ptz"])

    labels_tmp = ["Distal"]
    for i in range(1, N_REGIONS - 1):
        labels_tmp.append(f"Middle {i}")
    labels_tmp.append("Proximal")

    labels = [labels_tmp[reg_num] for reg_num in regions]

    ax.set_xticks(np.arange(1, len(labels) + 1), labels=labels)
    ax.set_xlim(0.25, len(labels) + 0.75)
    ax.set_xlabel("Cell region")
    if percent:
        ylabel = ylabel + " [%]"
    ax.set_ylabel(ylabel)

    ax.grid(visible=True, axis="y", alpha=0.7)
    ax.set_title(title)


def plot_two_features(
    x_path,
    y_path,
    results_dict,
    scale_path,
    color_path,
    evt_num,
    cell_length,
    do_regression=False,
    reg_intervals=None,
    piecewise_regression=False,
    plot_cluster_boundaries=False,
    plot_axis=False,
):
    do_scaling = scale_path[0].lower() != "none"
    if do_scaling:
        scale_min, scale_max = scale_min_max(
            results_dict, [scale_path], [False, True], evt_num, cell_length
        )

    spec_dict = {
        "isi": [
            300,
        ],
        "exp_name": EXP_NAMES,
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    paths = [x_path, y_path]
    columns = grab_columns(sub_results_dict, paths)
    color_column = grab_columns(sub_results_dict, [color_path])[0]

    if do_scaling:
        scale_columns = grab_columns(sub_results_dict, [scale_path])
        s_max = 20
        s_min = 1
        scale = np.array(scale_columns[0])
        dot_size = ((scale - scale_min) / (scale_max - scale_min)) * (
            s_max - s_min
        ) + s_min

    else:
        dot_size = 10

    x = np.array(columns[0])
    y = np.array(columns[1])

    plt.figure()

    if color_path[0] == "ptz":
        ptz_mask = np.array(color_column, dtype=bool)
        ctrl_mask = np.logical_not(ptz_mask)
        plt.scatter(
            x[ctrl_mask], y[ctrl_mask], s=dot_size, color="darkgray", label="ctrl"
        )
        plt.scatter(x[ptz_mask], y[ptz_mask], s=dot_size, color="brown", label="ptz")

    else:
        plt.scatter(x, y, s=dot_size, c=color_column, cmap=cm.viridis)
        cbar = plt.colorbar()
        cbar.set_label(color_path[-1])

    sub_t_val = 0.5

    if do_regression:
        if piecewise_regression:
            neg_proximal = y < 0
            sub_t = np.logical_and(
                np.logical_and(x >= 0, x < sub_t_val),
                np.logical_and(y >= 0, y < sub_t_val),
            )
            amplifying = np.logical_and(y > x, y >= sub_t_val)
            attenuating = np.logical_and(y < x, x >= sub_t_val)

            for mask, label in zip(
                [neg_proximal, sub_t, amplifying, attenuating],
                ["negative", "sub_threshold", "amplifying", "attenuating"],
            ):
                x_masked, y_masked = x[mask], y[mask]
                reg = linregress(x_masked, y_masked)
                x_reg = np.array([np.amin(x_masked), np.amax(x_masked)])
                plt.plot(
                    x_reg,
                    reg.intercept + x_reg * reg.slope,
                    linestyle="--",
                    color="gray",
                    alpha=0.8,
                    label=f"{label}\nR^2 = {reg.rvalue**2:.4f}\nslope = {reg.slope:.2f}\nintercept = {reg.intercept:.2f}",
                )

        elif reg_intervals is not None:
            for reg_int in reg_intervals:
                mask = np.logical_and(x >= reg_int[0], x < reg_int[1])
                x_masked, y_masked = x[mask], y[mask]
                reg = linregress(x_masked, y_masked)
                x_reg = np.array([np.amin(x_masked), np.amax(x_masked)])

                label = f"{reg_int[0]} < x < {reg_int[1]}"
                plt.plot(
                    x_reg,
                    reg.intercept + x_reg * reg.slope,
                    linestyle="--",
                    color="gray",
                    alpha=0.8,
                    label=f"{label}\nR^2 = {reg.rvalue**2:.4f}\nslope = {reg.slope:.2f}\nintercept = {reg.intercept:.2f}",
                )

        else:
            reg = linregress(x, y)
            x_reg = np.array([np.amin(x), np.amax(x)])
            plt.plot(
                x_reg,
                reg.intercept + x_reg * reg.slope,
                linestyle="--",
                color="gray",
                alpha=0.8,
                label=f"R^2 = {reg.rvalue**2:.4f}\nslope = {reg.slope:.2f}\nintercept = {reg.intercept:.2f}",
            )

    if plot_cluster_boundaries:
        x_min = np.amin(x)
        x_max = np.amax(x)
        y_min = np.amin(y)
        y_max = np.amax(y)
        lstyle = "--"
        lcolor = "gray"
        lalpha = 0.8

        subt = sub_t_val

        # sub_threshold
        plt.plot([0, subt], [subt, subt], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([0, subt], [0, 0], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([subt, subt], [0, subt], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([0, 0], [0, subt], linestyle=lstyle, color=lcolor, alpha=lalpha)

        # amplifying/attenuating
        plt.plot(
            [subt, min(x_max, y_max)],
            [subt, min(x_max, y_max)],
            linestyle=lstyle,
            color=lcolor,
            alpha=lalpha,
        )
        plt.plot([0, 0], [subt, y_max], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([subt, x_max], [0, 0], linestyle=lstyle, color=lcolor, alpha=lalpha)

        # negative
        plt.plot([-1, -1], [0, -1], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([-1, subt], [-1, -1], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([subt, subt], [-1, 0], linestyle=lstyle, color=lcolor, alpha=lalpha)
        plt.plot([-1, subt], [0, 0], linestyle=lstyle, color=lcolor, alpha=lalpha)

    if plot_axis:
        x_min = np.amin(x)
        x_max = np.amax(x)
        y_min = np.amin(y)
        y_max = np.amax(y)

        lcolor = "darkgray"
        lalpha = 0.9
        plt.hlines(0, x_min, x_max, color=lcolor, alpha=lalpha)
        plt.vlines(0, y_min, y_max, color=lcolor, alpha=lalpha)

    plt.legend()
    if x_path[0] == "regions":
        x_label = x_path[2] + " " + x_path[1]
    else:
        x_label = x_path[-1]
    if y_path[0] == "regions":
        y_label = y_path[2] + " " + y_path[1]
    else:
        y_label = y_path[-1]
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    """ if x_path[-1] == "amp":
        plt.xlim((-1.1, 5.5))
    if y_path[-1] == "amp":
        plt.ylim((-1.1, 5.5)) """


def plot_2d_manifold(
    paths, color_paths, results_dict, evt_num, cell_length, perplexity=40
):
    spec_dict = {
        "isi": [
            300,
        ],
        "exp_name": EXP_NAMES,
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    columns = grab_columns(sub_results_dict, paths)
    color_columns = grab_columns(sub_results_dict, color_paths)

    data = np.array(columns).T

    # manifold = PCA(n_components=2)
    manifold = TSNE(
        n_components=2, learning_rate="auto", init="pca", perplexity=perplexity
    )
    data_man = manifold.fit_transform(data)

    dotsize = 8

    x = data_man[:, 0]
    y = data_man[:, 1]

    for color_path, color_column in zip(color_paths, color_columns):
        plt.figure()

        if color_path[0] == "ptz":
            ptz_mask = np.array(color_column, dtype=bool)
            ctrl_mask = np.logical_not(ptz_mask)
            plt.scatter(
                x[ctrl_mask], y[ctrl_mask], s=dotsize, color="darkgray", label="ctrl"
            )
            plt.scatter(x[ptz_mask], y[ptz_mask], s=dotsize, color="brown", label="ptz")

        else:
            plt.scatter(x, y, s=dotsize, c=color_column, cmap=cm.viridis)
            cbar = plt.colorbar()
            if color_path[0] == "regions":
                c_label = color_path[2] + " " + color_path[1]
            else:
                c_label = color_path[-1]
            cbar.set_label(c_label)

        plt.legend()
        plt.xlabel("T-SNE1")
        plt.ylabel("T-SNE2")


def plot_slope_scatter_wrap(results_dict, stat_path, evt_num, cell_length):
    spec_dict = {
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    paths = [stat_path, ["ptz"]]
    columns = grab_columns(sub_results_dict, paths)

    ptz_metric = []
    ctrl_metric = []
    for slope, ptz in zip(columns[0], columns[1]):
        if ptz:
            ptz_metric.append(slope)
        else:
            ctrl_metric.append(slope)

    feature_unit = ""
    if stat_path[-1] == "amp_slope":
        feature_unit = r"($\Delta$F/F)/$\mu$m"

    elif stat_path[-1] == "t_peak_slope" or stat_path[-1] == "t_onset_slope":
        feature_unit = r"sec/$\mu$m"

    plot_slope_scatter(ctrl_metric, ptz_metric, stat_path[-1], feature_unit)


def plot_cell_overview_amp(results_dict, evt_num, cell_length):
    print(len(results_dict["ptz"]))
    spec_dict = {
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    amp_d_path = ["regions", f"r{DISTAL_REG+1}", "amp"]
    amp_p_path = ["regions", f"r{PROXIMAL_REG+1}", "amp"]
    ptz_path = ["ptz"]
    roi_num_path = ["roi_number"]
    exp_name_path = ["exp_name"]
    evt_num_path = ["evt_num"]

    paths = [
        amp_d_path,
        amp_p_path,
        ptz_path,
        roi_num_path,
        exp_name_path,
        evt_num_path,
    ]
    columns = grab_columns(sub_results_dict, paths)

    amp_d = np.array(columns[0])
    amp_p = np.array(columns[1])
    ptz = np.array(columns[2])
    roi_num = np.array(columns[3])
    exp_names = columns[4]
    evt_nums = np.array(columns[5])

    exp_names_set = set(exp_names)
    exp_nums = []
    for exp_name_evt in exp_names:
        for exp_num, exp_name in enumerate(exp_names_set):
            if exp_name_evt == exp_name:
                exp_nums.append(exp_num)
                continue

    exp_nums = np.array(exp_nums)

    for exp_name in exp_names_set:
        spec_dict = {"exp_name": [exp_name]}
        result_evt_indices = get_indices(results_dict, spec_dict)
        sub_result_evt_indices = get_indices(sub_results_dict, spec_dict)

        print(
            f"num_evts {exp_name}:\n - results_dict: {len(result_evt_indices)}\n - sub_results_dict: {len(sub_result_evt_indices)}\n"
        )

    num_evts = 5
    sorting_val = (
        np.logical_not(ptz) * 1000 + exp_nums * 100 + roi_num + evt_nums / 100.0
    )
    sort_ind = np.argsort(sorting_val)
    ind_rect = np.reshape(sort_ind, (-1, num_evts))

    t_val = 0.3

    negative = amp_p < 0
    amplifying = np.logical_and(amp_p > t_val, amp_p > amp_d)
    attenuating = np.logical_and(amp_d > t_val, amp_p < amp_d)
    sub_t = np.logical_and(
        np.logical_and(amp_p >= 0, amp_p < t_val),
        np.logical_and(amp_d >= 0, amp_p < t_val),
    )
    undefined = np.logical_not(
        np.logical_or(
            np.logical_or(negative, amplifying), np.logical_or(attenuating, sub_t)
        )
    )

    num_cells = ind_rect.shape[0]
    im = np.zeros((num_cells, num_evts, 3), dtype=int)
    for cell_num in range(num_cells):
        for evt_num in range(num_evts):
            ind = ind_rect[cell_num, evt_num]
            if negative[ind]:
                im[cell_num, evt_num] = NEGATIVE_RGB
            if sub_t[ind]:
                im[cell_num, evt_num] = SUBTHRESHOLD_RGB
            if amplifying[ind]:
                im[cell_num, evt_num] = AMPLIFYING_RGB
            if attenuating[ind]:
                im[cell_num, evt_num] = ATTENUATING_RGB
            if undefined[ind]:
                im[cell_num, evt_num] = UNDEFINED_RGB

    plt.figure()
    plt.imshow(im, aspect="auto", origin="upper")
    plt.xlabel("Event number")
    plt.ylabel("Cell number")
    plt.tight_layout()

    num_ptz = np.sum(ptz)
    ctrl = np.logical_not(ptz)
    num_ctrl = np.sum(ctrl)

    w = 0.2

    category_masks = [negative, sub_t, amplifying, attenuating, undefined]
    category_mask_label = [
        "negative",
        "sub_t",
        "amplifying",
        "attenuating",
        "undefined",
    ]

    fig, ax = plt.subplots()

    x0s = np.arange(len(category_masks))

    for x0, cat_mask in zip(x0s, category_masks):
        x_c = x0 - w / 2
        x_p = x0 + w / 2

        y_c = np.sum(np.logical_and(ctrl, cat_mask)) / num_ctrl
        y_p = np.sum(np.logical_and(ptz, cat_mask)) / num_ptz
        ax.bar(x_c, y_c, edgecolor="black", width=w, color="darkgray")
        ax.bar(x_p, y_p, edgecolor="black", width=w, color="brown")

    ax.set_xticks(x0s, category_mask_label)
    ax.set_ylabel("Frequency of category")


def plot_cell_overview_onset(results_dict, evt_num, cell_length):
    print(len(results_dict["ptz"]))
    spec_dict = {
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    t_onset_p_path = ["regions", f"r{PROXIMAL_REG+1}", "t_onset"]
    ptz_path = ["ptz"]
    roi_num_path = ["roi_number"]
    exp_name_path = ["exp_name"]
    evt_num_path = ["evt_num"]

    paths = [
        t_onset_p_path,
        ptz_path,
        roi_num_path,
        exp_name_path,
        evt_num_path,
    ]
    columns = grab_columns(sub_results_dict, paths)

    t_onset_p = np.array(columns[0])
    ptz = np.array(columns[1])
    roi_num = np.array(columns[2])
    exp_names = columns[3]
    evt_nums = np.array(columns[4])

    exp_names_set = set(exp_names)
    exp_nums = []
    for exp_name_evt in exp_names:
        for exp_num, exp_name in enumerate(exp_names_set):
            if exp_name_evt == exp_name:
                exp_nums.append(exp_num)
                continue

    exp_nums = np.array(exp_nums)

    for exp_name in exp_names_set:
        spec_dict = {"exp_name": [exp_name]}
        result_evt_indices = get_indices(results_dict, spec_dict)
        sub_result_evt_indices = get_indices(sub_results_dict, spec_dict)

        print(
            f"num_evts {exp_name}:\n - results_dict: {len(result_evt_indices)}\n - sub_results_dict: {len(sub_result_evt_indices)}\n"
        )

    num_evts = 5
    sorting_val = (
        np.logical_not(ptz) * 1000 + exp_nums * 100 + roi_num + evt_nums / 100.0
    )
    sort_ind = np.argsort(sorting_val)
    ind_rect = np.reshape(sort_ind, (-1, num_evts))

    t_val_1 = 4
    t_val_2 = 10

    early = t_onset_p < t_val_1
    middle = np.logical_and(t_onset_p >= t_val_1, t_onset_p < t_val_2)
    late = t_onset_p >= t_val_2

    num_cells = ind_rect.shape[0]
    im = np.zeros((num_cells, num_evts, 3), dtype=int)
    for cell_num in range(num_cells):
        for evt_num in range(num_evts):
            ind = ind_rect[cell_num, evt_num]
            if early[ind]:
                im[cell_num, evt_num] = EARLY_RGB
            if middle[ind]:
                im[cell_num, evt_num] = MIDDLE_RGB
            if late[ind]:
                im[cell_num, evt_num] = LATE_RGB

    plt.figure()
    plt.imshow(im, aspect="auto", origin="upper")
    plt.xlabel("Event number")
    plt.ylabel("Cell number")
    plt.tight_layout()

    num_ptz = np.sum(ptz)
    ctrl = np.logical_not(ptz)
    num_ctrl = np.sum(ctrl)

    w = 0.2

    category_masks = [early, middle, late]
    category_mask_label = [
        "early",
        "middle",
        "late",
    ]

    fig, ax = plt.subplots()

    x0s = np.arange(len(category_masks))

    for x0, cat_mask in zip(x0s, category_masks):
        x_c = x0 - w / 2
        x_p = x0 + w / 2

        y_c = np.sum(np.logical_and(ctrl, cat_mask)) / num_ctrl
        y_p = np.sum(np.logical_and(ptz, cat_mask)) / num_ptz
        ax.bar(x_c, y_c, edgecolor="black", width=w, color="darkgray")
        ax.bar(x_p, y_p, edgecolor="black", width=w, color="brown")

    ax.set_xticks(x0s, category_mask_label)
    ax.set_ylabel("Frequency of category")


def scale_min_max(results_dict, scale_paths, ptz, evt_num, cell_length):
    scale_min = np.inf
    scale_max = -np.inf

    spec_dict = {
        "ptz": ptz,
        "isi": [
            300,
        ],
        "exp_name": EXP_NAMES,
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }

    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    scale_columns = grab_columns(sub_results_dict, scale_paths)
    num_evts = len(scale_columns[0])

    for evt_ind in range(num_evts):
        for reg_num in range(N_REGIONS):
            scale_reg_evt = np.array(scale_columns[reg_num][evt_ind])
            scale_min = min(np.amin(scale_reg_evt), scale_min)
            scale_max = max(np.amax(scale_reg_evt), scale_max)

    return scale_min, scale_max


def get_dot_size_per_reg(scale_per_reg, scale_min, scale_max, dotsize_min, dotsize_max):
    num_evts = len(scale_per_reg[0])

    dotsizes = []
    for reg_num in range(N_REGIONS):
        dotsize_reg = []
        for evt_ind in range(num_evts):
            scale = np.array(scale_per_reg[reg_num][evt_ind])
            dotsize_reg_evt = ((scale - scale_min) / (scale_max - scale_min)) * (
                dotsize_max - dotsize_min
            ) + dotsize_min
            dotsize_reg.append(dotsize_reg_evt.tolist())

        dotsizes.append(dotsize_reg)

    return dotsizes


def get_dot_size(scale, scale_min, scale_max, dotsize_min, dotsize_max):
    scale = np.array(scale)
    dotsizes = ((scale - scale_min) / (scale_max - scale_min)) * (
        dotsize_max - dotsize_min
    ) + dotsize_min

    return dotsizes.tolist()


def plot_t_onsets_all(
    results_dict, region_colors, evt_num, cell_length, plot_categories=False
):
    scale_paths = [
        ["regions", f"r{reg_num+1}", "diff_dxdts"] for reg_num in range(N_REGIONS)
    ]
    stat_paths = [
        ["regions", f"r{reg_num+1}", "t_onsets"] for reg_num in range(N_REGIONS)
    ]

    scale_min, scale_max = scale_min_max(
        results_dict, scale_paths, [False, True], evt_num, cell_length
    )

    for ptz in [True, False]:
        spec_dict = {
            "ptz": [ptz],
            "isi": [
                300,
            ],
            "exp_name": EXP_NAMES,
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "evt_num": evt_num,
            "cell_length": cell_length,
        }

        evt_indices = get_indices(results_dict, spec_dict)
        sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

        stat_columns = grab_columns(sub_results_dict, stat_paths)
        scale_columns = grab_columns(sub_results_dict, scale_paths)
        num_evts = len(scale_columns[0])

        dotsizes = get_dot_size_per_reg(scale_columns, scale_min, scale_max, 1, 30)

        plt.figure()

        for evt_ind in range(num_evts):
            for reg_num in range(N_REGIONS):
                x = stat_columns[reg_num][evt_ind]
                y = (
                    np.ones(len(x)) * (N_REGIONS - reg_num)
                    + evt_ind / num_evts / 2
                    - 0.25
                )

                plt.scatter(
                    x, y, color=region_colors[reg_num], s=dotsizes[reg_num][evt_ind]
                )

        plt.ylabel("Region")
        plt.xlabel("Time [sec]")
        plt.xlim((-3, 15))
        plt.ylim((0, N_REGIONS + 1))

        plt.title(f"Time onsets by region {'[ptz]' if ptz else '[ctrl]'}")
        plt.tight_layout()

        if plot_categories:
            t_onset_path = [
                ["regions", f"r{reg_num+1}", "t_onset"] for reg_num in range(N_REGIONS)
            ]
            t_onsets = np.array(grab_columns(sub_results_dict, t_onset_path))
            ind_cats, cat_labels = get_t_onset_groups(t_onsets)

            for evt_inds, cat_label in zip(ind_cats, cat_labels):
                plt.figure()

                for evt_ind in evt_inds:
                    for reg_num in range(N_REGIONS):
                        x = stat_columns[reg_num][evt_ind]
                        y = (
                            np.ones(len(x)) * (N_REGIONS - reg_num)
                            + evt_ind / num_evts / 2
                            - 0.25
                        )

                        plt.scatter(
                            x,
                            y,
                            color=region_colors[reg_num],
                            s=dotsizes[reg_num][evt_ind],
                        )

                plt.ylabel("Region")
                plt.xlabel("Time [sec]")
                plt.xlim((-3, 15))
                plt.ylim((0, N_REGIONS + 1))

                plt.title(
                    f"Time onsets by region {'[ptz]' if ptz else '[ctrl]'} group= {cat_label}"
                )
                plt.tight_layout()


def plot_t_onset_max(
    results_dict, region_colors, evt_num, cell_length, plot_categories=False
):
    scale_paths = [
        ["regions", f"r{reg_num+1}", "diff_dxdt"] for reg_num in range(N_REGIONS)
    ]
    stat_paths = [
        ["regions", f"r{reg_num+1}", "t_onset"] for reg_num in range(N_REGIONS)
    ]

    scale_min, scale_max = scale_min_max(
        results_dict, scale_paths, [False, True], evt_num, cell_length
    )

    for ptz in [True, False]:
        spec_dict = {
            "ptz": [ptz],
            "isi": [
                300,
            ],
            "exp_name": EXP_NAMES,
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "evt_num": evt_num,
            "cell_length": cell_length,
        }

        evt_indices = get_indices(results_dict, spec_dict)
        sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

        stat_columns = grab_columns(sub_results_dict, stat_paths)
        scale_columns = grab_columns(sub_results_dict, scale_paths)
        num_evts = len(scale_columns[0])

        dotsize_min = 1
        dotsize_max = 30
        dotsizes = []
        for reg_num in range(N_REGIONS):
            dotsize_reg = []
            for evt_ind in range(num_evts):
                scale = scale_columns[reg_num][evt_ind]
                dotsize_reg_evt = ((scale - scale_min) / (scale_max - scale_min)) * (
                    dotsize_max - dotsize_min
                ) + dotsize_min
                dotsize_reg.append(dotsize_reg_evt)

            dotsizes.append(dotsize_reg)

        plt.figure()

        for reg_num in range(N_REGIONS):
            x = stat_columns[reg_num]
            y = np.linspace(
                N_REGIONS - reg_num - 0.25, N_REGIONS - reg_num + 0.25, num_evts
            )

            plt.scatter(x, y, color=region_colors[reg_num], s=dotsizes[reg_num])

        plt.ylabel("Region")
        plt.xlabel("Time [sec]")
        plt.xlim((-3, 15))
        plt.ylim((0, N_REGIONS + 1))

        plt.title(f"Time onsets by region {'[ptz]' if ptz else '[ctrl]'}")
        plt.tight_layout()

        if plot_categories:
            t_onsets = np.array(stat_columns)
            ind_cats, cat_labels = get_t_onset_groups(t_onsets)

            for evt_inds, cat_label in zip(ind_cats, cat_labels):
                plt.figure()

                for reg_num in range(N_REGIONS):
                    x = [stat_columns[reg_num][evt_ind] for evt_ind in evt_inds]
                    y = np.linspace(
                        N_REGIONS - reg_num - 0.25, N_REGIONS - reg_num + 0.25, len(x)
                    )
                    color = region_colors[reg_num]
                    dotsize = [dotsizes[reg_num][evt_ind] for evt_ind in evt_inds]

                    plt.scatter(
                        x,
                        y,
                        color=color,
                        s=dotsize,
                    )

                plt.ylabel("Region")
                plt.xlabel("Time [sec]")
                plt.xlim((-3, 15))
                plt.ylim((0, N_REGIONS + 1))

                plt.title(
                    f"Time onsets by region {'[ptz]' if ptz else '[ctrl]'} group= {cat_label}"
                )
                plt.tight_layout()


def amp_regions_generating_code(results_dict, evt_num, cell_length):
    reg_ints = [[-1, 0.3], [0.3, 10]]

    metric = "amp"
    metric2 = "bl"

    """ plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        metric,
        evt_num,
        cell_length,
        "Amplitude",
        percent=True,
        test_median=True,
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(1, N_REGIONS)],
        "rel_diff_amp",
        evt_num,
        cell_length,
        "Rel. diff. amplitude wrt distal region",
        percent=True,
        test_median=True,
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "bl",
        evt_num,
        cell_length,
        "Baseline",
        percent=True,
        test_median=True,
    ) """

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "t_rise",
        evt_num,
        cell_length,
        "Time rise [sec]",
        percent=False,
        test_median=True,
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "t_peak",
        evt_num,
        cell_length,
        "Time peak [sec]",
        percent=False,
        test_median=True,
    )

    plot_two_features(
        ["regions", f"r{DISTAL_REG+1}", metric],
        ["regions", f"r{PROXIMAL_REG+1}", metric],
        results_dict,
        ["none"],
        ["ptz"],
        evt_num,
        cell_length,
        do_regression=False,
        piecewise_regression=False,
        plot_cluster_boundaries=False,
        plot_axis=False,
    )

    plot_two_features(
        ["regions", f"r{DISTAL_REG+1}", metric],
        ["regions", f"r{PROXIMAL_REG+1}", metric],
        results_dict,
        ["none"],
        ["regions", f"r{PROXIMAL_REG+1}", "bl"],
        evt_num,
        cell_length,
        do_regression=True,
        piecewise_regression=False,
        reg_intervals=reg_ints,
        plot_cluster_boundaries=False,
        plot_axis=True,
    )

    plot_cell_overview_amp(results_dict, evt_num, cell_length)

    """ paths = [["regions", f"r{reg_num+1}", "amp"] for reg_num in range(N_REGIONS - 1)]
    color_paths = [["regions", f"r{PROXIMAL_REG+1}", "amp"], ["ptz"]]

    plot_2d_manifold(
        paths,
        color_paths,
        results_dict,
        evt_num,
        cell_length,
    )

    paths = [["regions", f"r{reg_num+1}", "amp"] for reg_num in range(1, N_REGIONS)]
    color_paths = [["regions", f"r{DISTAL_REG+1}", "amp"], ["ptz"]]

    plot_2d_manifold(
        paths,
        color_paths,
        results_dict,
        evt_num,
        cell_length,
    ) """


def t_lag_regions_generating_code(results_dict, evt_num, cell_length):

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(1, N_REGIONS)],
        "t_lag_distal",
        evt_num,
        cell_length,
        "Time lag rel distal",
        percent=False,
        test_median=True,
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(1, N_REGIONS)],
        "corr_distal",
        evt_num,
        cell_length,
        "Corr rel distal",
        percent=False,
        test_median=True,
    )

    plot_two_features(
        ["t_lag_distal_slope"],
        ["amp_slope"],
        results_dict,
        ["none"],
        ["ptz"],
        evt_num,
        cell_length,
        do_regression=False,
        piecewise_regression=False,
        plot_cluster_boundaries=False,
        plot_axis=False,
    )

    """ paths = [
        ["regions", f"r{reg_num+1}", "t_lag_distal"] for reg_num in range(1, N_REGIONS)
    ] + [["regions", f"r{reg_num+1}", "amp"] for reg_num in range(N_REGIONS)]
    color_paths = [["amp_slope"], ["ptz"]]

    plot_2d_manifold(
        paths,
        color_paths,
        results_dict,
        evt_num,
        cell_length,
        perplexity=20,
    ) """


def t_onset_regions_generating_code(results_dict, region_colors, evt_num, cell_length):

    """plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "acc_onset",
        evt_num,
        cell_length,
        "Acceleration 0-5 sec after light on",
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "acc_offset",
        evt_num,
        cell_length,
        "Acceleration 5-10 sec after light on",
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "acc_onset",
        evt_num,
        cell_length,
        "Acceleration 10-15 sec after light on",
    )"""

    """ plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "t_onset",
        evt_num,
        cell_length,
        "time onset [sec]",
    )

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(1, N_REGIONS)],
        "rel_t_onset",
        evt_num,
        cell_length,
        "time onset [sec]",
    ) """

    plot_t_onsets_all(
        results_dict, region_colors, evt_num, cell_length, plot_categories=True
    )
    """ plot_t_onset_max(
        results_dict, region_colors, evt_num, cell_length, plot_categories=True
    ) """

    # plot_cell_overview_onset(results_dict, evt_num, cell_length)

    """ paths = (
        [["regions", f"r{reg_num+1}", "rel_t_onset"] for reg_num in range(1, N_REGIONS)]
        + [["regions", f"r{DISTAL_REG+1}", "t_onset"]]
        + [["regions", f"r{DISTAL_REG+1}", "amp"]]
        + [
            ["regions", f"r{reg_num+1}", "rel_diff_amp"]
            for reg_num in range(1, N_REGIONS)
        ]
    )

    color_paths = [["amp_slope"], ["ptz"], ["t_onset_slope"]]

    plot_2d_manifold(
        paths,
        color_paths,
        results_dict,
        evt_num,
        cell_length,
    ) """

    """ for color_path in [
        ["amp_slope"],
        ["ptz"],
    ]:
        plot_two_features(
            ["t_onset_pearsonr"],
            ["t_onset_slope"],
            results_dict,
            ["none"],
            color_path,
            evt_num,
            cell_length,
        )

        plot_two_features(
            ["t_onset_slope"],
            ["amp_slope"],
            results_dict,
            ["none"],
            color_path,
            evt_num,
            cell_length,
        ) """


def t_decay_regions_generating_code(results_dict, region_colors, evt_num, cell_length):

    plot_stat_per_region_violin(
        results_dict,
        [reg_num for reg_num in range(N_REGIONS)],
        "t_decay",
        evt_num,
        cell_length,
        "time decay peak->0.8peak [sec]",
    )

    plot_stat_per_region_scatter(
        results_dict,
        region_colors,
        "t_constant_decay",
        ["none"],
        evt_num,
        cell_length,
        "decay time constant [sec]",
    )


def t_onset_cat_generating_code(results_dict, region_colors, evt_num, cell_length):
    spec_dict = {
        "exp_name": EXP_NAMES,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    t_onsets_path = [
        ["regions", f"r{reg_num+1}", "t_onset"] for reg_num in range(N_REGIONS)
    ]
    ptz_path = ["ptz"]
    amp_d_path = ["regions", f"r{DISTAL_REG+1}", "amp"]
    amp_p_path = ["regions", f"r{PROXIMAL_REG+1}", "amp"]
    amp_slope_path = ["amp_slope"]
    t_lag_slope_path = ["t_lag_distal_slope"]
    t_peak_slope_path = ["t_peak_slope"]

    paths = [
        ptz_path,
        amp_d_path,
        amp_p_path,
        amp_slope_path,
        t_lag_slope_path,
        t_peak_slope_path,
    ]
    columns = grab_columns(sub_results_dict, paths)

    ptz = np.array(columns[0])
    amp_d = np.array(columns[1])
    amp_p = np.array(columns[2])
    amp_slope = np.array(columns[3])
    t_lag_slope = np.array(columns[4])
    t_peak_slope = np.array(columns[5])

    zs = [amp_d, amp_p, amp_slope, t_lag_slope, t_peak_slope]
    z_labels = [
        "Amplitude distal",
        "Amplitude proximal",
        "Amplitude slope",
        "Time lag slope",
        "Time peak slope",
    ]

    t_onsets = np.array(grab_columns(sub_results_dict, t_onsets_path))
    cat_inds, cat_labels = get_t_onset_groups(t_onsets)

    x0s = np.arange(len(cat_labels))
    w = 0.5
    dotsize = 8

    for z, z_label in zip(zs, z_labels):
        plt.figure()
        for x0, cat_ind in zip(x0s, cat_inds):
            num_evt = len(cat_ind)
            x = np.linspace(x0 - w / 2, x0 + w / 2, num=num_evt)
            y = []
            colors = []
            for ind in cat_ind:
                y.append(z[ind])
                ptz_ = ptz[ind]
                colors.append("brown" if ptz_ else "darkgray")

            plt.scatter(x, y, s=dotsize, c=colors, alpha=0.9)

        plt.xticks(x0s, cat_labels)
        plt.ylabel(z_label)


def main():
    results_dir = generate_global_results_dir()
    fig_dir = generate_figures_dir()

    lrs_fig_dir = os.path.join(fig_dir, "light_response_stats")
    reg_colors = REG_CM(np.linspace(0, 1, N_REGIONS))

    with open(gen_pickle_fname(results_dir, STATS_FNAME), "rb") as f:
        results_dict = pickle.load(f)

    evt_num = [0, 1, 2, 3, 4]
    cell_length = [55]

    """ for prop_dist in range(N_REGIONS):
        opt_spec_dict = {"prop_dist": [prop_dist]}
        plot_stat_per_region_scatter(
            results_dict,
            reg_colors,
            "amp",
            ["regions", "r6", "amp"],
            evt_num,
            cell_length,
            lrs_fig_dir,
            ["t_onset_per_region_ctrl", "t_onset_per_region_ptz"],
            opt_spec_dict=opt_spec_dict,
        ) """

    """ for prop_dist in range(N_REGIONS):
        opt_spec_dict = {"prop_dist": [prop_dist]}
        plot_stat_per_region_scatter(
            results_dict,
            reg_colors,
            "t_onset",
            ["regions", "r6", "amp"],
            evt_num,
            cell_length,
            lrs_fig_dir,
            ["t_onset_per_region_ctrl", "t_onset_per_region_ptz"],
            opt_spec_dict=opt_spec_dict,
        ) """

    """ plot_stat_per_region_scatter(
        results_dict,
        reg_colors,
        "t_decay",
        ["regions", "r5", "amp"],
        evt_num,
        cell_length,
        lrs_fig_dir,
        ["t_onset_per_region_ctrl", "t_onset_per_region_ptz"],
    ) """

    """ plot_stat_per_region_scatter(
        results_dict,
        reg_colors,
        "acc_onset",
        ["regions", "r6", "amp"],
        evt_num,
        cell_length,
    )

    plot_stat_per_region_scatter(
        results_dict,
        reg_colors,
        "acc_middle",
        ["regions", f"r{PROXIMAL_REG+1}", "amp"],
        evt_num,
        cell_length,
    ) """

    """ plot_stat_per_region_scatter(
        results_dict,
        reg_colors,
        "acc_offset",
        ["regions", f"r{PROXIMAL_REG+1}", "amp"],
        evt_num,
        cell_length,
    ) """

    """ plot_slope_scatter_wrap(results_dict, ["t_onset_slope"], evt_num, cell_length)

    plot_slope_scatter_wrap(results_dict, ["t_peak_slope"], evt_num, cell_length)

    plot_slope_scatter_wrap(results_dict, ["amp_slope"], evt_num, cell_length) """

    """ plot_two_features(
        ["regions", f"r{PROXIMAL_REG+1}", "t_onset"],
        ["regions", f"r{PROXIMAL_REG+1}", "amp"],
        results_dict,
        ["None"],
        ["ptz"],
        evt_num,
        cell_length,
    )

    plot_two_features(
        ["t_onset_slope"],
        ["amp_slope"],
        results_dict,
        ["None"],
        ["ptz"],
        evt_num,
        cell_length,
    ) """

    """ plot_two_features(
        ["regions", f"r{PROXIMAL_REG+1}", "peak"],
        ["regions", f"r{PROXIMAL_REG+1}", "t_decay"],
        results_dict,
        evt_num,
        cell_length,
    ) """

    # amp_regions_generating_code(results_dict, evt_num, cell_length)

    # t_lag_regions_generating_code(results_dict, evt_num, cell_length)

    t_onset_regions_generating_code(results_dict, reg_colors, evt_num, cell_length)

    # t_decay_regions_generating_code(results_dict, reg_colors, evt_num, cell_length)

    # t_onset_cat_generating_code(results_dict, reg_colors, evt_num, cell_length)

    plt.show()


if __name__ == "__main__":
    main()
