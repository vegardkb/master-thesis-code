import numpy as np
from matplotlib import pyplot as plt
import matplotlib.cm as cm
import pickle
import copy

from fio import (
    generate_global_results_dir,
    gen_pickle_fname,
)
from plotters import plot_slope_box, plot_slope_scatter
from data_analysis_events import EventType
from sklearn.decomposition import PCA


EXP_NAMES = [
    "20211112_13_23_43_GFAP_GCamp6s_F2_PTZ",
    "20211112_18_30_27_GFAP_GCamp6s_F5_c2",
    "20211112_19_48_54_GFAP_GCamp6s_F6_c3",
    # "20211117_14_17_58_GFAP_GCamp6s_F2_C",
    # "20211117_17_33_00_GFAP_GCamp6s_F4_PTZ",
    "20211117_21_31_08_GFAP_GCamp6s_F6_PTZ",
    "20211119_16_36_20_GFAP_GCamp6s_F4_PTZ",
    # "20211119_18_15_06_GFAP_GCamp6s_F5_C",
    # "20211119_21_52_35_GFAP_GCamp6s_F7_C",
    "20220211_13_18_56_GFAP_GCamp6s_F2_C",
    # "20220211_15_02_16_GFAP_GCamp6s_F3_PTZ",
    "20220211_16_51_15_GFAP_GCamp6s_F4_PTZ",
    # "20220412_10_43_04_GFAP_GCamp6s_F1_PTZ",
    "20220412_12_32_27_GFAP_GCamp6s_F2_PTZ",
    "20220412_13_59_55_GFAP_GCamp6s_F3_C",
    # "20220412_16_06_54_GFAP_GCamp6s_F4_PTZ",
]
STATS_FNAME = "stats_light_response"

N_REGIONS = 6
DISTAL_REG = 0
PROXIMAL_REG = N_REGIONS - 1

CELL_LENGTH_THRESHOLDS = [40, 60]

# ISIS = [300, 120, 60, 30, 15]
ISIS = [300, 120, 60]

REG_CM = cm.viridis_r


def create_empty_results_dict(region_keys):
    region_dict = {
        "peak": [],
        "bl": [],
        "amp": [],
        "t_onset": [],
        "t_rise": [],
        "t_peak": [],
        "t_decay": [],
        "reg_position": [],
        "acc_onset": [],
        "acc_middle": [],
        "acc_offset": [],
    }
    results_dict = {
        "exp_name": [],
        "roi_number": [],
        "isi": [],
        "ptz": [],
        "evt_num": [],
        "amp_slope": [],
        "t_onset_slope": [],
        "t_peak_slope": [],
        "regions": {reg_key: copy.deepcopy(region_dict) for reg_key in region_keys},
    }
    return results_dict


def get_indices(results_dict, spec_dict):
    """
    results_dict: dictionary generated by light_response_feature_extract
    spec_dict: dictionary specifying what events to get indices for, values are lists

    return: list of indices corresponding to events that adhere to spec_dict

    example spec_dict:
        {
            "regions": ["r1"],
            "ptz": [True],
            "isi": [300],
        }
        This will give indices for all responses
        where the fish was treated with ptz and 300 seconds passed since last light stim.
        "regions" key is ignored and used elsewhere since one index includes all regions
    """

    event_ind_list = []
    num_events = len(results_dict["exp_name"])
    for event_ind in range(num_events):
        include_evt = True
        for key, val_list in spec_dict.items():
            if key == "regions":
                continue

            if results_dict[key][event_ind] not in val_list:
                include_evt = False
                break

        if include_evt:
            event_ind_list.append(event_ind)

    return event_ind_list


def get_results_dict(results_dict, event_ind_list, spec_dict):
    region_keys = spec_dict["regions"]
    sub_results_dict = create_empty_results_dict(region_keys)

    for evt_ind in event_ind_list:
        sub_results_dict["exp_name"].append(results_dict["exp_name"][evt_ind])
        sub_results_dict["roi_number"].append(results_dict["roi_number"][evt_ind])
        sub_results_dict["isi"].append(results_dict["isi"][evt_ind])
        sub_results_dict["ptz"].append(results_dict["ptz"][evt_ind])
        sub_results_dict["evt_num"].append(results_dict["evt_num"][evt_ind])
        sub_results_dict["amp_slope"].append(results_dict["amp_slope"][evt_ind])
        sub_results_dict["t_onset_slope"].append(results_dict["t_onset_slope"][evt_ind])
        sub_results_dict["t_peak_slope"].append(results_dict["t_peak_slope"][evt_ind])

        for reg_key in region_keys:
            sub_results_dict["regions"][reg_key]["peak"].append(
                results_dict["regions"][reg_key]["peak"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["bl"].append(
                results_dict["regions"][reg_key]["bl"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["amp"].append(
                results_dict["regions"][reg_key]["amp"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_onset"].append(
                results_dict["regions"][reg_key]["t_onset"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_rise"].append(
                results_dict["regions"][reg_key]["t_rise"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_peak"].append(
                results_dict["regions"][reg_key]["t_peak"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["t_decay"].append(
                results_dict["regions"][reg_key]["t_decay"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["reg_position"].append(
                results_dict["regions"][reg_key]["reg_position"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["acc_onset"].append(
                results_dict["regions"][reg_key]["acc_onset"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["acc_middle"].append(
                results_dict["regions"][reg_key]["acc_middle"][evt_ind]
            )
            sub_results_dict["regions"][reg_key]["acc_offset"].append(
                results_dict["regions"][reg_key]["acc_offset"][evt_ind]
            )

    return sub_results_dict


def grab_columns(results_dict, paths):
    """
    paths: list of lists specifying path to list to extract

    Example paths:
        [["isi"], ["regions", "r1", "amp"]]
    """
    columns = []
    for path in paths:
        tmp = results_dict
        for key in path:
            tmp = tmp[key]

        columns.append(tmp)

    return columns


def main():
    results_dir = generate_global_results_dir()
    reg_colors = REG_CM(np.linspace(0, 1, N_REGIONS))

    with open(gen_pickle_fname(results_dir, STATS_FNAME), "rb") as f:
        results_dict = pickle.load(f)

    evt_num = [0, 1, 2, 3, 4]
    cell_length = [60]

    paths = []
    for reg_num in range(N_REGIONS):
        for feature in ["acc_onset", "acc_middle", "acc_offset", "amp"]:
            paths.append(["regions", f"r{reg_num+1}", feature])

    spec_dict = {
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }

    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    x = np.array(grab_columns(sub_results_dict, paths))
    ptz_mask = np.array(grab_columns(sub_results_dict, [["ptz"]])[0])

    pca = PCA(n_components=2)

    x_pca = pca.fit_transform(x.T)
    x_pca_ptz = x_pca[ptz_mask == True]
    x_pca_ctrl = x_pca[ptz_mask == False]

    plt.figure()

    plt.scatter(x_pca_ptz[:, 0], x_pca_ptz[:, 1], s=4, color="brown")
    plt.scatter(x_pca_ctrl[:, 0], x_pca_ctrl[:, 1], s=4, color="darkgray")

    plt.show()


if __name__ == "__main__":
    main()
