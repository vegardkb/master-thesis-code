import numpy as np
from matplotlib import pyplot as plt
import matplotlib.cm as cm
import pickle
import copy
import os
from scipy import signal

from fio import (
    generate_global_results_dir,
    gen_pickle_fname,
    gen_npy_fname,
    generate_figures_dir,
    gen_image_fname,
)
from data_analysis_events import EventType
from light_response_feature_extract import create_empty_results_dict
from light_response_plot_stats import get_results_dict, get_t_onset_groups


EXP_NAMES = [
    "20211112_13_23_43_GFAP_GCamp6s_F2_PTZ",
    "20211112_18_30_27_GFAP_GCamp6s_F5_c2",
    "20211112_19_48_54_GFAP_GCamp6s_F6_c3",
    "20211117_21_31_08_GFAP_GCamp6s_F6_PTZ",
    "20211119_16_36_20_GFAP_GCamp6s_F4_PTZ",
    "20220211_13_18_56_GFAP_GCamp6s_F2_C",
    "20220412_12_32_27_GFAP_GCamp6s_F2_PTZ",
    "20220412_13_59_55_GFAP_GCamp6s_F3_C",
]
CROP_IDS = ["OpticTectum"]

DFF_REGS_FNAME = "dff_light_response"
CURVATURE_REGS_FNAME = "curvature_light_response"
SECOND_DERIVATIVE_FNAME = "d2xdt2_light_response"
STATS_FNAME = "stats_light_response"

MICROM_PER_M = 1000000
N_REGIONS = 8
DISTAL_REG = 0
PROXIMAL_REG = N_REGIONS - 1
BUFFER_T = 5
PRE_EVENT_T = 5
POST_EVENT_T = 60
POST_STIM_T = 30

CURVATURE_THRESHOLD = 0.95

STIM_ONSET = 0
STIM_DURATION = 10
STIM_OFFSET = STIM_ONSET + STIM_DURATION

VOLUME_RATE = 4.864
MAX_LAG = 30

USE_DENOISED = True
USE_CHAN2 = False

REG_CM = cm.viridis_r


def get_indices(results_dict, spec_dict):
    """
    results_dict: dictionary generated by light_response_feature_extract
    spec_dict: dictionary specifying what events to get indices for, values are lists

    return: list of indices corresponding to events that adhere to spec_dict

    example spec_dict:
        {
            "regions": ["r1"],
            "ptz": [True],
            "isi": [300],
        }
        This will give indices for all responses
        where the fish was treated with ptz and 300 seconds passed since last light stim.
        "regions" key is ignored and used elsewhere since one index includes all regions
    """

    event_ind_list = []
    num_events = len(results_dict["exp_name"])
    for event_ind in range(num_events):
        include_evt = True
        for key, val_list in spec_dict.items():
            if key == "regions":
                continue

            if results_dict[key][event_ind] not in val_list:
                include_evt = False
                break

        if include_evt:
            event_ind_list.append(event_ind)

    return event_ind_list


def get_dff_regs(dff_regs, event_ind_list, spec_dict):
    """
    dff_regs: list of ndarrays(num_frames, num_regs)
    """
    region_keys = spec_dict["regions"]
    reg_inds_spec = [int(reg_key[1]) - 1 for reg_key in region_keys]
    sub_dff_regs = []

    for evt_ind in event_ind_list:
        num_regs = dff_regs[evt_ind].shape[1]
        reg_inds = []
        for reg_ind in reg_inds_spec:
            if reg_ind < num_regs:
                reg_inds.append(reg_ind)
        sub_dff_regs.append(dff_regs[evt_ind][:, reg_inds])

    return sub_dff_regs


def get_dff_reg_np(dff_regs):
    num_events = len(dff_regs)
    max_regs = 0
    min_frames = np.inf
    for dff_reg in dff_regs:
        min_frames = min(dff_reg.shape[0], min_frames)
        max_regs = max(dff_reg.shape[1], max_regs)

    print(f"num_events = {num_events}")
    print(f"min_frames = {min_frames}")
    print(f"max_regs = {max_regs}")

    dff_reg_np = np.zeros((num_events, min_frames, max_regs))
    nan_count = 0
    inf_count = 0
    for i, dff_reg in enumerate(dff_regs):
        num_regs_evt = dff_reg.shape[1]
        dff_reg_np[i, :, :num_regs_evt] = dff_reg[:min_frames]
        if num_regs_evt < max_regs:
            dff_reg_np[i, :, num_regs_evt:] = np.nan

        if np.any(np.isnan(dff_reg)):
            nan_count += 1
        if np.any(np.isinf(dff_reg)):
            inf_count += 1

    print(f"num events with nan = {nan_count}")
    print(f"num events with inf = {inf_count}")
    print(f"nan in dff_reg_np = {np.any(np.isnan(dff_reg_np))}")
    print(f"inf in dff_reg_np = {np.any(np.isinf(dff_reg_np))}")

    return dff_reg_np


def calc_average_std_dff_trace(dff_regs):
    dff_reg_np = get_dff_reg_np(dff_regs)
    av_dff_reg = np.mean(dff_reg_np, axis=0)
    std_dff_reg = np.std(dff_reg_np, axis=0)
    num_evts_reg = np.sum(np.logical_not(np.any(np.isnan(dff_reg_np), axis=1)), axis=0)
    return av_dff_reg, std_dff_reg, num_evts_reg


def grab_columns(results_dict, paths):
    """
    paths: list of lists specifying path to list to extract

    Example paths:
        [["isi"], ["regions", "r1", "amp"]]
    """
    columns = []
    for path in paths:
        tmp = results_dict
        for key in path:
            tmp = tmp[key]

        columns.append(tmp)

    return columns


def n_placement(num_evt_reg):
    n_in_title = False
    n_in_legend = False

    if np.all(num_evt_reg == num_evt_reg[0]):
        # Same number of observations each region
        n_in_title = True
        n_in_legend = False
    else:
        # Different number of observations each region
        n_in_title = False
        n_in_legend = True

    return n_in_title, n_in_legend


def plot_trace(
    t,
    av_dff_reg,
    std_dff_reg,
    num_evt_reg,
    reg_colors,
    plt_std=False,
    std_alpha=0.3,
    fill_std=False,
    fill_alpha=0.1,
    xlim=None,
    ylim=None,
    title=None,
    vlines=None,
    vlines_colors=None,
    vlines_ylim=(0.1, 0.9),
    vlines_alpha=0.4,
    ylabel=None,
):
    _, ax = plt.subplots(figsize=(10, 10))

    n_in_title, n_in_legend = n_placement(num_evt_reg)

    for reg_num in range(av_dff_reg.shape[1]):
        label = (
            f"Region {reg_num+1} (n = {num_evt_reg[reg_num]})"
            if n_in_legend
            else f"R{reg_num+1}"
        )
        ax.plot(
            t,
            av_dff_reg[:, reg_num],
            color=reg_colors[reg_num],
            label=label,
        )

        if plt_std:
            ax.plot(
                t,
                av_dff_reg[:, reg_num] + std_dff_reg[:, reg_num],
                color=reg_colors[reg_num],
                alpha=std_alpha,
            )
            ax.plot(
                t,
                av_dff_reg[:, reg_num] - std_dff_reg[:, reg_num],
                color=reg_colors[reg_num],
                alpha=std_alpha,
            )
            if fill_std:
                ax.fill_between(
                    t,
                    av_dff_reg[:, reg_num] - std_dff_reg[:, reg_num],
                    av_dff_reg[:, reg_num] + std_dff_reg[:, reg_num],
                    color=reg_colors[reg_num],
                    alpha=fill_alpha,
                )

    ax.set_xlabel("Time [sec]")
    ax.set_ylabel(r"Baseline subtracted $\Delta$F/F")
    ax.legend()

    if xlim is not None:
        ax.set_xlim(xlim[0], xlim[1])

    if ylim is not None:
        ax.set_ylim(ylim[0], ylim[1])

    if title is not None:
        if n_in_title:
            title = title + f" (n = {num_evt_reg[0]})"
        ax.set_title(title)

    if vlines is not None:
        for i, vline in enumerate(vlines):
            ax.axvline(
                vline,
                vlines_ylim[0],
                vlines_ylim[1],
                color=vlines_colors[i],
                alpha=vlines_alpha,
            )

    if ylabel is not None:
        ax.set_ylabel(ylabel)


def filter_event_indices(path, threshold, results_dict, threshold_upper=None):
    tmp = copy.deepcopy(results_dict)
    for key in path:
        tmp = tmp[key]
    x = tmp

    ind_pos = []
    ind_neg = []
    nan_arr_bool = np.isnan(x)
    for i, val in enumerate(x):
        if nan_arr_bool[i]:
            continue

        if threshold_upper is not None:
            if val >= threshold and val < threshold_upper:
                ind_pos.append(i)

            else:
                ind_neg.append(i)

        else:
            if val >= threshold:
                ind_pos.append(i)

            else:
                ind_neg.append(i)

    return ind_pos, ind_neg


def and_list(x, y):
    z = []
    for val in x:
        if val in y:
            z.append(val)

    return z


def plot_trace_filter(
    results_dict,
    dff_regs,
    stat_path,
    thresholds,
    region_colors,
    ptz,
    evt_num,
    cell_length,
):
    spec_dict = {
        "ptz": ptz,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

    thresholds = [-np.inf] + sorted(thresholds) + [np.inf]
    dff_regs = []
    for t_l, t_h in zip(thresholds[:-1], thresholds[1:]):
        print(f"t_l = {t_l}")
        print(f"t_h = {t_h}")
        ind_pos, _ = filter_event_indices(
            stat_path, t_l, sub_results_dict, threshold_upper=t_h
        )
        dff_reg = get_dff_regs(sub_dff_regs, ind_pos, spec_dict)
        av_dff_regs_pos, std_dff_regs_pos, num_evt_reg_pos = calc_average_std_dff_trace(
            dff_reg
        )

        num_frames = av_dff_regs_pos.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = f"ptz: {ptz},"
        stat_name = stat_path[-1]
        plot_trace(
            t,
            av_dff_regs_pos,
            std_dff_regs_pos,
            num_evt_reg_pos,
            reg_colors=region_colors,
            title=group + f" {t_l} =< {stat_name} < {t_h},",
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        )


def plot_distal_proximal_amp_clusters(
    results_dict, dff_regs, region_colors, ptz, evt_num, cell_length
):
    spec_dict = {
        "ptz": ptz,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

    amp_distal_path = ["regions", f"r{DISTAL_REG+1}", "amp"]
    amp_proximal_path = ["regions", f"r{PROXIMAL_REG+1}", "amp"]
    amp_slope_path = ["amp_slope"]

    t_val = 0.5

    neg_distal_ind, _ = filter_event_indices(
        amp_distal_path, -np.inf, sub_results_dict, 0
    )
    small_distal_ind, _ = filter_event_indices(
        amp_distal_path, 0, sub_results_dict, t_val
    )
    large_distal_ind, _ = filter_event_indices(
        amp_distal_path, t_val, sub_results_dict, np.inf
    )

    neg_proximal_ind, _ = filter_event_indices(
        amp_proximal_path, -np.inf, sub_results_dict, 0
    )
    small_proximal_ind, _ = filter_event_indices(
        amp_proximal_path, 0, sub_results_dict, t_val
    )
    large_proximal_ind, _ = filter_event_indices(
        amp_proximal_path, t_val, sub_results_dict, np.inf
    )

    pos_slope_ind, _ = filter_event_indices(amp_slope_path, 0, sub_results_dict, np.inf)

    amp_ind = and_list(large_proximal_ind, pos_slope_ind)
    att_ind = and_list(large_distal_ind, small_proximal_ind)
    small_ind = and_list(small_distal_ind, small_proximal_ind)
    neg_ind = and_list(neg_distal_ind, neg_proximal_ind)

    evt_inds = [amp_ind, att_ind, small_ind, neg_ind]
    names = ["Amplifying", "Attenuating", "Subthreshold", "Negative"]

    for evt_ind, name in zip(evt_inds, names):
        dff_reg = get_dff_regs(sub_dff_regs, evt_ind, spec_dict)
        av_dff_reg, std_dff_reg, num_evt = calc_average_std_dff_trace(dff_reg)

        num_frames = av_dff_reg.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = f"ptz: {ptz},"
        plot_trace(
            t,
            av_dff_reg,
            std_dff_reg,
            num_evt,
            reg_colors=region_colors,
            title=group + f" {name},",
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        )


def plot_t_onset_clusters(
    results_dict, dff_regs, region_colors, ptz, evt_num, cell_length
):
    spec_dict = {
        "ptz": ptz,
        "exp_name": EXP_NAMES,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

    t_onsets_path = [
        ["regions", f"r{reg_num+1}", "t_onset"] for reg_num in range(N_REGIONS)
    ]
    t_onsets = np.array(grab_columns(sub_results_dict, t_onsets_path))

    evt_inds, names = get_t_onset_groups(t_onsets)

    for evt_ind, name in zip(evt_inds, names):
        dff_reg = get_dff_regs(sub_dff_regs, evt_ind, spec_dict)
        av_dff_reg, std_dff_reg, num_evt = calc_average_std_dff_trace(dff_reg)

        num_frames = av_dff_reg.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = f"ptz: {ptz},"
        plot_trace(
            t,
            av_dff_reg,
            std_dff_reg,
            num_evt,
            reg_colors=region_colors,
            title=group + f" {name},",
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        )


def plot_schematic_amp(
    results_dict,
    dff_regs,
    exp_name,
    reg_num,
    roi_num,
    evt_num,
    cell_length,
):
    spec_dict = {
        "exp_name": [exp_name],
        "roi_number": [roi_num],
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": [evt_num],
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    if not len(evt_indices):
        return

    dff_reg = get_dff_regs(dff_regs, evt_indices, spec_dict)[0][:, reg_num]
    evt_ind = evt_indices[0]

    bl = results_dict["regions"][f"r{reg_num+1}"]["bl"][evt_ind]
    amp = results_dict["regions"][f"r{reg_num+1}"]["amp"][evt_ind]
    peak = results_dict["regions"][f"r{reg_num+1}"]["peak"][evt_ind]
    t_amp = results_dict["regions"][f"r{reg_num+1}"]["t_peak"][evt_ind]
    t_onset = results_dict["regions"][f"r{reg_num+1}"]["t_onset"][evt_ind]
    t_decay = results_dict["regions"][f"r{reg_num+1}"]["t_decay"][evt_ind]

    dff_reg = dff_reg + bl

    num_frames = dff_reg.shape[0]
    t = (
        np.linspace(
            -PRE_EVENT_T * VOLUME_RATE,
            -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
            num_frames,
        )
        / VOLUME_RATE
    )
    _, ax = plt.subplots(figsize=(10, 10))

    ax.plot(
        t,
        dff_reg,
        color="black",
    )

    ax.set_xlabel("Time [sec]")
    ax.set_ylabel(r"$\Delta$F/F")

    vlines = [STIM_ONSET, STIM_OFFSET]
    vlines_colors = ["orange", "darkgray"]
    vlines_ylim = (0, 1)
    vlines_alpha = 0.7

    for i, vline in enumerate(vlines):
        ax.axvline(
            vline,
            vlines_ylim[0],
            vlines_ylim[1],
            color=vlines_colors[i],
            alpha=vlines_alpha,
        )

    bl_color = "green"
    amp_color = "red"
    decay_color = "purple"

    bl_t = STIM_ONSET - PRE_EVENT_T / 2
    bl_ymin = min(bl, 0)
    bl_ymax = max(bl, 0)
    amp_ymin = min(bl, amp + bl)
    amp_ymax = max(bl, amp + bl)

    ax.vlines(bl_t, bl_ymin, bl_ymax, color=bl_color, label="Baseline")
    ax.axhline(bl, 0, 1, linestyle="--", color="gray")
    ax.axhline(0, 0, 1, color="darkgray")
    ax.vlines(t_amp, amp_ymin, amp_ymax, color=amp_color, label="Amplitude")
    """ ax.hlines(
        peak * CURVATURE_THRESHOLD,
        t_amp,
        t_amp + t_decay,
        color=decay_color,
        label="Decay time",
    ) """

    ax.legend()
    ax.grid(visible=False)


def plot_schematic_time_lag_distal(
    results_dict,
    dff_regs,
    exp_name,
    region_colors,
    roi_num,
    evt_num,
    cell_length,
):
    spec_dict = {
        "exp_name": [exp_name],
        "roi_number": [roi_num],
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": [evt_num],
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    if not len(evt_indices):
        return

    dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)[0]

    num_frames = dff_regs.shape[0]
    t = (
        np.linspace(
            -PRE_EVENT_T * VOLUME_RATE,
            -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
            num_frames,
        )
        / VOLUME_RATE
    )
    t_interest = (-PRE_EVENT_T, STIM_DURATION + POST_STIM_T)
    t_mask = np.logical_and(t >= t_interest[0], t < t_interest[1])

    _, ax = plt.subplots(figsize=(10, 10))

    labels_tmp = ["Distal"]
    for i in range(1, N_REGIONS - 1):
        labels_tmp.append(f"Middle {i}")
    labels_tmp.append("Proximal")

    labels = [labels_tmp[reg_num] for reg_num in range(N_REGIONS)]

    for reg_num, reg_color, label in zip(range(N_REGIONS), region_colors, labels):
        ax.plot(t[t_mask], dff_regs[t_mask, reg_num], color=reg_color, label=label)
        ax.plot(
            t[np.logical_not(t_mask)],
            dff_regs[np.logical_not(t_mask), reg_num],
            color=reg_color,
            alpha=0.4,
        )

    ax.set_xlabel("Time [sec]")
    ax.set_ylabel(r"$\Delta$F/F")
    ax.set_title("Example light response")

    vlines = [STIM_ONSET, STIM_OFFSET]
    vlines_colors = ["orange", "darkgray"]
    vlines_ylim = (0, 1)
    vlines_alpha = 0.7

    for i, vline in enumerate(vlines):
        ax.axvline(
            vline,
            vlines_ylim[0],
            vlines_ylim[1],
            color=vlines_colors[i],
            alpha=vlines_alpha,
        )

    ax.legend()
    ax.grid(visible=False)

    plt.figure()
    x_ref = dff_regs[t_mask, DISTAL_REG]
    for reg_num, reg_color, label in zip(
        range(1, N_REGIONS), region_colors[1:], labels[1:]
    ):
        x = dff_regs[t_mask, reg_num]
        mu_x = np.mean(x)
        mu_ref = np.mean(x_ref)
        norm_x = np.sqrt(np.sum(np.power(x - mu_x, 2)))
        norm_ref = np.sqrt(np.sum(np.power(x_ref - mu_ref, 2)))
        corr = signal.correlate(x - np.mean(x), x_ref - np.mean(x_ref), mode="same")
        norm = norm_x * norm_ref

        corr = corr / norm
        lags = np.arange(x.shape[0]) / VOLUME_RATE
        lags = lags - np.amax(lags) / 2

        lag_mask = np.absolute(lags) < MAX_LAG
        lags = lags[lag_mask]
        corr = corr[lag_mask]

        max_ind = np.argmax(corr)
        plt.plot(lags, corr, color=reg_color, label=label, alpha=0.9)
        plt.scatter(
            [lags[max_ind]], [corr[max_ind]], color=reg_color, marker="x", alpha=0.9
        )

    plt.legend()
    plt.xlabel("Lag [sec]")
    plt.ylabel("Correlation")
    plt.grid()
    plt.title("Example crosscorrelation with distal region")


def plot_t_onset_slope_corr_clusters(
    results_dict, dff_regs, region_colors, ptz, evt_num, cell_length
):
    spec_dict = {
        "ptz": ptz,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

    t_onset_slope_path = ["t_onset_slope"]
    t_onset_pearsonr_path = ["t_onset_pearsonr"]

    t_val_slope = 0
    t_val_corr = 0.6

    outwards_ind, _ = filter_event_indices(
        t_onset_slope_path, -np.inf, sub_results_dict, t_val_slope
    )
    inwards_ind, _ = filter_event_indices(
        t_onset_slope_path, t_val_slope, sub_results_dict, np.inf
    )

    nonlinear_ind, _ = filter_event_indices(
        t_onset_pearsonr_path, -np.inf, sub_results_dict, t_val_corr
    )
    linear_ind, _ = filter_event_indices(
        t_onset_pearsonr_path, t_val_corr, sub_results_dict, np.inf
    )

    inwards_linear = and_list(inwards_ind, linear_ind)
    outwards_linear = and_list(outwards_ind, linear_ind)
    inwards_nonlinear = and_list(inwards_ind, nonlinear_ind)
    outwards_nonlinear = and_list(outwards_ind, nonlinear_ind)

    evt_inds = [inwards_linear, outwards_linear, inwards_nonlinear, outwards_nonlinear]
    names = [
        "inwards_linear",
        "outwards_linear",
        "inwards_nonlinear",
        "outwards_nonlinear",
    ]

    for evt_ind, name in zip(evt_inds, names):
        dff_reg = get_dff_regs(sub_dff_regs, evt_ind, spec_dict)
        av_dff_reg, std_dff_reg, num_evt = calc_average_std_dff_trace(dff_reg)

        num_frames = av_dff_reg.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = f"ptz: {ptz},"
        plot_trace(
            t,
            av_dff_reg,
            std_dff_reg,
            num_evt,
            reg_colors=region_colors,
            title=group + f" {name},",
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        )


def plot_light_response_w_onsets(
    results_dict,
    dff_regs,
    region_colors,
    ptz,
    exp_name,
    roi_num,
    evt_num,
    cell_length,
    ylabel=None,
    plot_mean=False,
):
    spec_dict = {
        "ptz": ptz,
        "exp_name": exp_name,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": [evt_num],
        "cell_length": cell_length,
        "roi_number": [roi_num],
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

    t_onsets_paths = [
        ["regions", f"r{reg_num+1}", "t_onsets"] for reg_num in range(N_REGIONS)
    ]
    t_onsets = grab_columns(sub_results_dict, t_onsets_paths)
    print(t_onsets)

    av_dff_reg, std_dff_reg, num_evt = calc_average_std_dff_trace(sub_dff_regs)

    num_frames = av_dff_reg.shape[0]
    t = (
        np.linspace(
            -PRE_EVENT_T * VOLUME_RATE,
            -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
            num_frames,
        )
        / VOLUME_RATE
    )
    plot_trace(
        t,
        av_dff_reg,
        std_dff_reg,
        num_evt,
        reg_colors=region_colors,
        title=exp_name + f" ROI {roi_num} evt {evt_num}",
        vlines=[STIM_ONSET, STIM_OFFSET],
        vlines_colors=["orange", "darkgray"],
        ylabel=ylabel,
    )

    if plot_mean:
        plt.plot(t, np.mean(av_dff_reg, axis=1), color="darkgray")

    dotsize = 5
    y = 0
    for reg_color, t_onsets_reg in zip(region_colors, t_onsets):
        ys = [y for _ in range(len(t_onsets_reg[0]))]
        plt.scatter(
            t_onsets_reg[0],
            ys,
            s=dotsize,
            color=reg_color,
        )


def plot_t_onsets_ex(
    results_dict,
    region_colors,
    exp_name,
    roi_num,
    evt_num,
    cell_length,
):
    scale_max = -np.inf
    scale_min = np.inf
    spec_dict = {
        "exp_name": exp_name,
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": [evt_num],
        "cell_length": cell_length,
        "roi_number": [roi_num],
    }

    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)

    stat_paths = [
        ["regions", f"r{reg_num+1}", "t_onsets"] for reg_num in range(N_REGIONS)
    ]
    scale_paths = [
        ["regions", f"r{reg_num+1}", "diff_dxdts"] for reg_num in range(N_REGIONS)
    ]

    stat_columns = grab_columns(sub_results_dict, stat_paths)
    scale_columns = grab_columns(sub_results_dict, scale_paths)

    stat_regs = []
    scale_regs = []

    for reg_num in range(N_REGIONS):
        scale_reg = np.array(scale_columns[reg_num][0])
        scale_regs.append(scale_reg)

        stat_reg = np.array(stat_columns[reg_num][0])
        stat_regs.append(stat_reg)

        scale_max = max(scale_max, np.amax(scale_reg))
        scale_min = min(scale_min, np.amin(scale_reg))

    dot_size_regs = []
    s_max = 100
    s_min = 1
    for reg_num in range(N_REGIONS):
        scale = np.array(scale_regs[reg_num])
        dot_size = ((scale - scale_min) / (scale_max - scale_min)) * (
            s_max - s_min
        ) + s_min
        dot_size_regs.append(dot_size)

    plt.figure()

    for reg_num in range(N_REGIONS):
        x = stat_regs[reg_num]
        y = np.ones(len(x)) * (N_REGIONS - reg_num)
        s = dot_size_regs[reg_num]
        print(f"x.shape : {x.shape}")
        print(f"x : {x}")
        print(f"y.shape : {y.shape}")
        print(f"y : {y}")
        print(f"s.shape : {s.shape}")
        print(f"s : {s}")

        max_ind = np.argmax(np.array(s))
        plt.scatter(x, y, color=region_colors[reg_num], s=s)
        plt.scatter(
            [x[max_ind]],
            [y[max_ind]],
            color="black",
            alpha=0.7,
            s=[s[max_ind] / 2],
            marker="x",
        )

    plt.ylabel("Region")
    plt.xlabel("Time [sec]")

    plt.title("Time onsets by region")
    plt.tight_layout()


def plot_zero_decay_trace(
    results_dict,
    dff_regs,
    region_colors,
    evt_num,
    cell_length,
):
    spec_dict = {
        "isi": [
            300,
        ],
        "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        "evt_num": evt_num,
        "cell_length": cell_length,
    }
    evt_indices = get_indices(results_dict, spec_dict)
    sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
    sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

    t_l = -np.inf
    t_h = 1
    ind_pos, _ = filter_event_indices(
        ["regions", f"r{PROXIMAL_REG+1}", "t_decay"],
        t_l,
        sub_results_dict,
        threshold_upper=t_h,
    )
    dff_regs = get_dff_regs(sub_dff_regs, ind_pos, spec_dict)

    for dff_reg in dff_regs:

        dff_reg = [dff_reg]
        av_dff_regs_pos, std_dff_regs_pos, num_evt_reg_pos = calc_average_std_dff_trace(
            dff_reg
        )

        num_frames = av_dff_regs_pos.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        plot_trace(
            t,
            av_dff_regs_pos,
            std_dff_regs_pos,
            num_evt_reg_pos,
            reg_colors=region_colors,
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        )
        plt.show()


def main():
    np.seterr(all="raise")

    results_dir = generate_global_results_dir()
    fig_dir = generate_figures_dir()

    lr_fig_dir = os.path.join(fig_dir, "light_response_trace")

    dff_regs = np.load(gen_npy_fname(results_dir, DFF_REGS_FNAME), allow_pickle=True)
    k_regs = np.load(
        gen_npy_fname(results_dir, CURVATURE_REGS_FNAME), allow_pickle=True
    )
    d2xdt2_regs = np.load(
        gen_npy_fname(results_dir, SECOND_DERIVATIVE_FNAME), allow_pickle=True
    )
    with open(gen_pickle_fname(results_dir, STATS_FNAME), "rb") as f:
        results_dict = pickle.load(f)

    evt_count = 0
    inf_count = 0
    nan_count = 0
    for dff_reg in dff_regs:
        evt_count += 1
        if np.any(np.isinf(dff_reg)):
            inf_count += 1
        if np.any(np.isnan(dff_reg)):
            nan_count += 1

    print(f"num_evts = {evt_count}")
    print(f"inf_count = {inf_count}")
    print(f"nan_count = {nan_count}\n")

    region_colors = REG_CM(np.linspace(0, 1, N_REGIONS))
    ptz = [True]
    cell_length = [55]
    evt_num = [0, 1, 2, 3, 4]

    """ for ptz in [False, True]:
        for cell_length in [60]:
            spec_dict = {
                "ptz": [ptz],
                "isi": [
                    300,
                ],
                "regions": ["r1", "r6"],
                "cell_length": [cell_length],
            }
            evt_indices = get_indices(results_dict, spec_dict)
            sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)
            av_dff_regs, std_dff_regs, num_evt_reg = calc_average_std_dff_trace(
                sub_dff_regs
            )
            num_frames = av_dff_regs.shape[0]
            t = (
                np.linspace(
                    -PRE_EVENT_T * VOLUME_RATE,
                    -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                    num_frames,
                )
                / VOLUME_RATE
            )
            group = "ptz" if ptz else "ctrl"
            group = group + f" length = {cell_length}"
            plot_trace(
                t,
                av_dff_regs,
                std_dff_regs,
                num_evt_reg,
                reg_colors=["orange", "purple"],
                plt_std=True,
                fill_std=True,
                title=group,
                vlines=[STIM_ONSET, STIM_OFFSET],
                vlines_colors=["orange", "darkgray"],
            )

    for ptz in [False, True]:
        for cell_length in [60]:
            spec_dict = {
                "ptz": [ptz],
                "isi": [
                    300,
                ],
                "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
                "cell_length": [cell_length],
            }
            evt_indices = get_indices(results_dict, spec_dict)
            sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)

            spec_dict = {
                "ptz": [ptz],
                "isi": [
                    300,
                ],
                "regions": ["r1", "r6"],
                "cell_length": [cell_length],
            }

            sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
            ind_pos, ind_neg = filter_event_indices(["amp_slope"], 0, sub_results_dict)

            dff_regs_pos = get_dff_regs(sub_dff_regs, ind_pos, spec_dict)
            (
                av_dff_regs_pos,
                std_dff_regs_pos,
                num_evt_reg_pos,
            ) = calc_average_std_dff_trace(dff_regs_pos)

            dff_regs_neg = get_dff_regs(sub_dff_regs, ind_neg, spec_dict)
            (
                av_dff_regs_neg,
                std_dff_regs_neg,
                num_evt_reg_neg,
            ) = calc_average_std_dff_trace(dff_regs_neg)

            num_frames = av_dff_regs_pos.shape[0]
            t = (
                np.linspace(
                    -PRE_EVENT_T * VOLUME_RATE,
                    -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                    num_frames,
                )
                / VOLUME_RATE
            )
            group = "ptz" if ptz else "ctrl"
            group = group + f" length = {cell_length}"
            plot_trace(
                t,
                av_dff_regs_pos,
                std_dff_regs_pos,
                num_evt_reg_pos,
                reg_colors=["orange", "purple"],
                plt_std=True,
                fill_std=True,
                title=group + " amp_slope > 0",
                vlines=[STIM_ONSET, STIM_OFFSET],
                vlines_colors=["orange", "darkgray"],
            )
            plot_trace(
                t,
                av_dff_regs_neg,
                std_dff_regs_neg,
                num_evt_reg_neg,
                reg_colors=["orange", "purple"],
                plt_std=True,
                fill_std=True,
                title=group + " amp_slope < 0",
                vlines=[STIM_ONSET, STIM_OFFSET],
                vlines_colors=["orange", "darkgray"],
            ) """

    """ for ptz in [False, True]:
        spec_dict = {
            "ptz": [ptz],
            "isi": [
                300,
            ],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "cell_length": [cell_length],
            "evt_num": [evt_num],
        }
        evt_indices = get_indices(results_dict, spec_dict)
        sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)
        av_dff_regs, std_dff_regs, num_evt_reg = calc_average_std_dff_trace(
            sub_dff_regs
        )
        num_frames = av_dff_regs.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = "ptz" if ptz else "ctrl"
        group = group + f" length = {cell_length}"
        plot_trace(
            t,
            av_dff_regs,
            std_dff_regs,
            num_evt_reg,
            reg_colors=region_colors,
            title=group,
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        ) """

    # plot_zero_decay_trace(results_dict, dff_regs, region_colors, evt_num, cell_length)

    """ plot_distal_proximal_amp_clusters(
        results_dict, dff_regs, region_colors, [False, True], evt_num, cell_length
    )

    plot_distal_proximal_amp_clusters(
        results_dict, d2xdt2_regs, region_colors, [False, True], evt_num, cell_length
    ) """

    """ plot_t_lag_av_amp_slope_clusters(
        results_dict, dff_regs, region_colors, [False, True], evt_num, cell_length
    ) """

    """ plot_t_onset_slope_corr_clusters(
        results_dict, dff_regs, region_colors, [False, True], evt_num, cell_length
    ) """

    plot_t_onset_clusters(
        results_dict, dff_regs, region_colors, [False], evt_num, cell_length
    )

    plot_t_onset_clusters(
        results_dict, dff_regs, region_colors, [True], evt_num, cell_length
    )

    """ plot_t_onset_clusters(
        results_dict, d2xdt2_regs, region_colors, [False, True], evt_num, cell_length
    ) """

    """ plot_trace_filter(
        results_dict,
        dff_regs,
        ["prop_dist"],
        [3],
        region_colors,
        [False],
        evt_num,
        cell_length,
    ) """

    """ for e_num in evt_num:

        plot_schematic_amp(
            results_dict,
            dff_regs,
            "20211112_13_23_43_GFAP_GCamp6s_F2_PTZ",
            DISTAL_REG,
            2,
            e_num,
            cell_length,
        ) """

    """ for ptz in [False, True]:
        spec_dict = {
            "ptz": [ptz],
            "isi": [
                300,
            ],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "cell_length": [cell_length],
            # "evt_num": [evt_num],
        }
        evt_indices = get_indices(results_dict, spec_dict)
        sub_dff_regs = get_dff_regs(k_regs, evt_indices, spec_dict)
        av_dff_regs, std_dff_regs, num_evt_reg = calc_average_std_dff_trace(
            sub_dff_regs
        )
        num_frames = av_dff_regs.shape[0]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = "ptz" if ptz else "ctrl"
        group = group + f" length = {cell_length}"
        plot_trace(
            t,
            av_dff_regs,
            std_dff_regs,
            num_evt_reg,
            reg_colors=region_colors,
            title=group,
            vlines=[STIM_ONSET, STIM_OFFSET],
            vlines_colors=["orange", "darkgray"],
        ) """

    """ for ptz in [False, True]:
        spec_dict = {
            "ptz": [ptz],
            "isi": [
                300,
            ],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        }
        evt_indices = get_indices(results_dict, spec_dict)
        sub_dff_regs = get_dff_regs(k_regs, evt_indices, spec_dict)
        dff_regs_np = get_dff_reg_np(sub_dff_regs)
        num_frames = dff_regs_np.shape[1]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = "curvature "
        group += "ptz" if ptz else "ctrl"
        plt.figure()
        plt.pcolormesh(
            t,
            np.linspace(1, dff_regs_np.shape[0], dff_regs_np.shape[0]),
            np.log10(dff_regs_np[:, :, DISTAL_REG] + 1),
            cmap=cm.inferno,
        )
        plt.title(group) """

    """ for ptz in [False, True]:
        spec_dict = {
            "ptz": [ptz],
            "isi": [
                300,
            ],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
        }
        evt_indices = get_indices(results_dict, spec_dict)
        sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)
        dff_regs_np = get_dff_reg_np(sub_dff_regs)
        num_frames = dff_regs_np.shape[1]
        t = (
            np.linspace(
                -PRE_EVENT_T * VOLUME_RATE,
                -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                num_frames,
            )
            / VOLUME_RATE
        )
        group = "dff "
        group += "ptz" if ptz else "ctrl"
        plt.figure()
        plt.pcolormesh(
            t,
            np.linspace(1, dff_regs_np.shape[0], dff_regs_np.shape[0]),
            dff_regs_np[:, :, DISTAL_REG],
            cmap=cm.inferno,
        )
        plt.title(group) """

    """ for exp_name in EXP_NAMES:
        lr_exp_fig_dir = os.path.join(lr_fig_dir, exp_name)
        if not os.path.isdir(lr_exp_fig_dir):
            os.makedirs(lr_exp_fig_dir)

        spec_dict = {
            "exp_name": [exp_name],
            "isi": [
                300,
            ],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "evt_num": evt_num,
        }
        evt_indices = get_indices(results_dict, spec_dict)
        sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
        roi_num_set = set(sub_results_dict["roi_number"])

        for roi_num in roi_num_set:
            for evt_n in evt_num:
                spec_dict = {
                    "exp_name": [exp_name],
                    "isi": [
                        300,
                    ],
                    "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
                    "evt_num": [evt_n],
                    "roi_number": [roi_num],
                }
                evt_indices = get_indices(results_dict, spec_dict)
                sub_k_regs = get_dff_regs(k_regs, evt_indices, spec_dict)
                av_k_regs, std_k_regs, num_evt_reg = calc_average_std_dff_trace(
                    sub_k_regs
                )
                sub_dff_regs = get_dff_regs(dff_regs, evt_indices, spec_dict)
                av_dff_regs, std_dff_regs, num_evt_reg = calc_average_std_dff_trace(
                    sub_dff_regs
                )
                sub_d2xdt2_regs = get_dff_regs(d2xdt2_regs, evt_indices, spec_dict)
                (
                    av_d2xdt2_regs,
                    std_d2xdt2_regs,
                    num_evt_reg,
                ) = calc_average_std_dff_trace(sub_d2xdt2_regs)
                num_frames = av_k_regs.shape[0]
                t = (
                    np.linspace(
                        -PRE_EVENT_T * VOLUME_RATE,
                        -PRE_EVENT_T * VOLUME_RATE + num_frames - 1,
                        num_frames,
                    )
                    / VOLUME_RATE
                )
                plot_trace(
                    t,
                    av_k_regs,
                    std_k_regs,
                    num_evt_reg,
                    reg_colors=region_colors,
                    title=exp_name + f" ROI {roi_num} evt {evt_n} curvature",
                    vlines=[STIM_ONSET, STIM_OFFSET],
                    vlines_colors=["orange", "darkgray"],
                )
                plot_trace(
                    t,
                    av_dff_regs,
                    std_dff_regs,
                    num_evt_reg,
                    reg_colors=region_colors,
                    title=exp_name + f" ROI {roi_num} evt {evt_n} dff",
                    vlines=[STIM_ONSET, STIM_OFFSET],
                    vlines_colors=["orange", "darkgray"],
                )
                plot_trace(
                    t,
                    av_d2xdt2_regs,
                    std_d2xdt2_regs,
                    num_evt_reg,
                    reg_colors=region_colors,
                    title=exp_name + f" ROI {roi_num} evt {evt_n} d2xdt2",
                    vlines=[STIM_ONSET, STIM_OFFSET],
                    vlines_colors=["orange", "darkgray"],
                )
                plt.show() """

    """ for exp_name in EXP_NAMES:
        spec_dict = {
            "exp_name": [exp_name],
            "isi": [
                300,
            ],
            "regions": [f"r{reg_num+1}" for reg_num in range(N_REGIONS)],
            "evt_num": evt_num,
        }
        evt_indices = get_indices(results_dict, spec_dict)
        sub_results_dict = get_results_dict(results_dict, evt_indices, spec_dict)
        roi_num_set = set(sub_results_dict["roi_number"])
        roi_num_set = [2]

        for roi_num in roi_num_set:
            for evt_n in evt_num:
                try:
                    plot_light_response_w_onsets(
                        results_dict,
                        dff_regs,
                        region_colors,
                        [False, True],
                        exp_name,
                        roi_num,
                        evt_n,
                        cell_length,
                    )
                    plot_light_response_w_onsets(
                        results_dict,
                        d2xdt2_regs,
                        region_colors,
                        [False, True],
                        exp_name,
                        roi_num,
                        evt_n,
                        cell_length,
                        ylabel=r"Second derivative $\Delta$F/F",
                    )
                    plot_t_onsets_ex(
                        results_dict,
                        region_colors,
                        exp_name,
                        roi_num,
                        evt_n,
                        cell_length,
                    )
                    plt.show()

                except TypeError:
                    continue """

    """ for e_num in evt_num:
        plot_schematic_time_lag_distal(
            results_dict,
            dff_regs,
            "20211112_13_23_43_GFAP_GCamp6s_F2_PTZ",
            region_colors,
            2,
            e_num,
            cell_length,
        )
        plt.show() """

    plt.show()


if __name__ == "__main__":
    main()
